
# mixer 
# anything global must be a constant ...
# type is deduced from the initialiser expression
# There are 3 types integer, float bool
# floats are differentiated by including a decimal point and fractional part
# bools are either true or false
# There is NO conversion between the different types
#  x = 1 ; // x is an integer
#  y = 1.0 ; // y is a float
#  z1 = x + x ; // OK z1 is an integer
#  z2 = x + y ; // Error : x and y are different types
#  b = true;   // b is a bool
#  c = b && x ;   // Error :  b and x are different types
#  d = b && !b ; // ok ( c is false)
#  w = x != 0  ; // w is bool 

pitch_gain = 500.0; # pitch gain surprisingly ( Just here to test comments)
roll_gain = 1000.0 - pitch_gain;
throttle_gain = 10.0;
pulse_offset = 1500.0;
thrt_pls_offset = 1000.0;

# Provide names for some of the output array indices
elevon_left = 1;
elevon_right = 2;

# An output in the mixer function is evaluated periodically
# (Possibly when the inputs connected to it change)
mixer()
{
   # in the mixer function expression can be variables as wel as constants

   F_deflection = (input(Airspeed) * input(Airspeed))/( input(ARSPD_FBWA_MIN) * input(ARSPD_FBWA_MIN)) ;
   pitch = input(Pitch) * pitch_gain;
   roll  = input(Roll) * roll_gain;

   # The output expressions
   output[elevon_left] = ( pitch + roll) / F_deflection + pulse_offset;
   output[elevon_right] = (pitch - roll) / F_deflection + pulse_offset;

   # just to show literals work also for outputs
   output[3] = input(Throttle) * throttle_gain + thrt_pls_offset;
}
